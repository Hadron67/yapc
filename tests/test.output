state 49,shift/reduce conflict:
  used:[ 21: assignOptr -> . <=>, { <(>,<id>,<num>,<function>, } ] (s4)
  discarded:[ 27: conditionalExpr -> binaryExpr <?> assignExpr <:> assignExpr ., { <)>,<,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ]* (r)

state 49,shift/reduce conflict:
  used:[ 22: assignOptr -> . <+=>, { <(>,<id>,<num>,<function>, } ] (s5)
  discarded:[ 27: conditionalExpr -> binaryExpr <?> assignExpr <:> assignExpr ., { <)>,<,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ]* (r)

state 49,shift/reduce conflict:
  used:[ 23: assignOptr -> . <-=>, { <(>,<id>,<num>,<function>, } ] (s6)
  discarded:[ 27: conditionalExpr -> binaryExpr <?> assignExpr <:> assignExpr ., { <)>,<,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ]* (r)

state 49,shift/reduce conflict:
  used:[ 24: assignOptr -> . <*=>, { <(>,<id>,<num>,<function>, } ] (s7)
  discarded:[ 27: conditionalExpr -> binaryExpr <?> assignExpr <:> assignExpr ., { <)>,<,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ]* (r)

state 49,shift/reduce conflict:
  used:[ 25: assignOptr -> . </=>, { <(>,<id>,<num>,<function>, } ] (s8)
  discarded:[ 27: conditionalExpr -> binaryExpr <?> assignExpr <:> assignExpr ., { <)>,<,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ]* (r)

state 80,reduce/reduce conflict:
  used:[ 18: exprList -> assignExpr ., { <)>,<,>, } ]* (r)
  discarded:[ 53: nonEmptyArgList -> assignExpr ., { <)>,<,>, } ]* (r)

state 80,reduce/reduce conflict:
  used:[ 18: exprList -> assignExpr ., { <)>,<,>, } ]* (r)
  discarded:[ 53: nonEmptyArgList -> assignExpr ., { <)>,<,>, } ]* (r)

state 86,shift/reduce conflict:
  used:[ 21: assignOptr -> . <=>, { <(>,<id>,<num>,<function>, } ] (s4)
  discarded:[ 48: lambdaBody -> assignExpr ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (r)

state 86,shift/reduce conflict:
  used:[ 22: assignOptr -> . <+=>, { <(>,<id>,<num>,<function>, } ] (s5)
  discarded:[ 48: lambdaBody -> assignExpr ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (r)

state 86,shift/reduce conflict:
  used:[ 23: assignOptr -> . <-=>, { <(>,<id>,<num>,<function>, } ] (s6)
  discarded:[ 48: lambdaBody -> assignExpr ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (r)

state 86,shift/reduce conflict:
  used:[ 24: assignOptr -> . <*=>, { <(>,<id>,<num>,<function>, } ] (s7)
  discarded:[ 48: lambdaBody -> assignExpr ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (r)

state 86,shift/reduce conflict:
  used:[ 25: assignOptr -> . </=>, { <(>,<id>,<num>,<function>, } ] (s8)
  discarded:[ 48: lambdaBody -> assignExpr ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (r)

state 93,shift/reduce conflict:
  used:[ 27: conditionalExpr -> binaryExpr . <?> assignExpr <:> assignExpr, { <)>,<,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ]* (s46)
  discarded:[ 26: conditionalExpr -> binaryExpr ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (r)

state 93,shift/reduce conflict:
  used:[ 28: binaryExpr -> binaryExpr . <+> multiplyExpr, { <+>,<->,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ]* (s50)
  discarded:[ 26: conditionalExpr -> binaryExpr ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (r)

state 93,shift/reduce conflict:
  used:[ 29: binaryExpr -> binaryExpr . <-> multiplyExpr, { <+>,<->,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ]* (s69)
  discarded:[ 26: conditionalExpr -> binaryExpr ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (r)

state 94,shift/reduce conflict:
  used:[ 31: multiplyExpr -> multiplyExpr . <*> unaryExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ]* (s52)
  discarded:[ 30: binaryExpr -> multiplyExpr ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (r)

state 94,shift/reduce conflict:
  used:[ 32: multiplyExpr -> multiplyExpr . </> unaryExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ]* (s54)
  discarded:[ 30: binaryExpr -> multiplyExpr ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (r)

state 98,shift/reduce conflict:
  used:[ 36: trailer -> trailer . <[> subscript <]>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ]* (s56)
  discarded:[ 35: atomicExpr -> atom trailer ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (r)

state 98,shift/reduce conflict:
  used:[ 37: trailer -> trailer . <(> argList <)>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ]* (s62)
  discarded:[ 35: atomicExpr -> atom trailer ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (r)

state 98,shift/reduce conflict:
  used:[ 38: trailer -> trailer . <member>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ]* (s71)
  discarded:[ 35: atomicExpr -> atom trailer ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (r)

i0
[ 0: (accept) -> . start, { <EOF>, } ]* (s1)
[ 1: start -> . statementList, { <EOF>, } ] (s2)
[ 2: statementList -> . statementList statement, { <EOF>,<(>,<id>,<num>,<;>,<{>,<if>,<while>,<for>,<function>, } ] (s2)
[ 3: statementList -> ., { <EOF>,<(>,<id>,<num>,<;>,<{>,<if>,<while>,<for>,<function>, } ] (r)

i1
[ 0: (accept) -> start ., { <EOF>, } ]* (r)

i2
[ 1: start -> statementList ., { <EOF>, } ]* (r)
[ 2: statementList -> statementList . statement, { <EOF>,<(>,<id>,<num>,<;>,<{>,<if>,<while>,<for>,<function>, } ]* (s3)
[ 4: statement -> . ifStatement <;>, { <EOF>,<(>,<id>,<num>,<;>,<{>,<if>,<while>,<for>,<function>, } ] (s18)
[ 5: statement -> . forStatement <;>, { <EOF>,<(>,<id>,<num>,<;>,<{>,<if>,<while>,<for>,<function>, } ] (s20)
[ 6: statement -> . whileStatement <;>, { <EOF>,<(>,<id>,<num>,<;>,<{>,<if>,<while>,<for>,<function>, } ] (s22)
[ 7: statement -> . <{> statementList <}>, { <EOF>,<(>,<id>,<num>,<;>,<{>,<if>,<while>,<for>,<function>, } ] (s24)
[ 8: statement -> . exprList <;>, { <EOF>,<(>,<id>,<num>,<;>,<{>,<if>,<while>,<for>,<function>, } ] (s27)
[ 9: statement -> . <;>, { <EOF>,<(>,<id>,<num>,<;>,<{>,<if>,<while>,<for>,<function>, } ] (s29)
[ 11: ifStatement -> . <if> @1 <(> exprList <)> statement elseStatement, { <;>, } ] (s9)
[ 15: forStatement -> . <for> <(> forExpr <;> exprList <;> exprList <;> <)> statement, { <;>, } ] (s30)
[ 14: whileStatement -> . <while> <(> exprList <)> statement, { <;>, } ] (s41)
[ 17: exprList -> . exprList <,> assignExpr, { <,>,<;>, } ] (s27)
[ 18: exprList -> . assignExpr, { <,>,<;>, } ] (s61)
[ 19: assignExpr -> . assignExpr assignOptr conditionalExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s61)
[ 20: assignExpr -> . conditionalExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s92)
[ 26: conditionalExpr -> . binaryExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s95)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s96)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s97)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s72)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s73)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s74)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s81)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s82)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s83)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s99)
[ 46: lambdaHead -> . <id>, { <arrow>, } ] (s72)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow>, } ] (s74)

i3
[ 2: statementList -> statementList statement ., { <EOF>,<(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function>, } ]* (r)

i4
[ 21: assignOptr -> <=> ., { <(>,<id>,<num>,<function>, } ]* (r)

i5
[ 22: assignOptr -> <+=> ., { <(>,<id>,<num>,<function>, } ]* (r)

i6
[ 23: assignOptr -> <-=> ., { <(>,<id>,<num>,<function>, } ]* (r)

i7
[ 24: assignOptr -> <*=> ., { <(>,<id>,<num>,<function>, } ]* (r)

i8
[ 25: assignOptr -> </=> ., { <(>,<id>,<num>,<function>, } ]* (r)

i9
[ 11: ifStatement -> <if> . @1 <(> exprList <)> statement elseStatement, { <;>, } ]* (s10)
[ 10: @1 -> ., { <(>, } ] (r)

i10
[ 11: ifStatement -> <if> @1 . <(> exprList <)> statement elseStatement, { <;>, } ]* (s11)

i11
[ 11: ifStatement -> <if> @1 <(> . exprList <)> statement elseStatement, { <;>, } ]* (s12)
[ 17: exprList -> . exprList <,> assignExpr, { <)>,<,>, } ] (s12)
[ 18: exprList -> . assignExpr, { <)>,<,>, } ] (s61)
[ 19: assignExpr -> . assignExpr assignOptr conditionalExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s61)
[ 20: assignExpr -> . conditionalExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s92)
[ 26: conditionalExpr -> . binaryExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s95)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s96)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s97)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s72)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s73)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s74)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s81)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s82)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s83)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s99)
[ 46: lambdaHead -> . <id>, { <arrow>, } ] (s72)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow>, } ] (s74)

i12
[ 11: ifStatement -> <if> @1 <(> exprList . <)> statement elseStatement, { <;>, } ]* (s13)
[ 17: exprList -> exprList . <,> assignExpr, { <)>,<,>, } ]* (s77)

i13
[ 11: ifStatement -> <if> @1 <(> exprList <)> . statement elseStatement, { <;>, } ]* (s14)
[ 4: statement -> . ifStatement <;>, { <;>,<else>, } ] (s18)
[ 5: statement -> . forStatement <;>, { <;>,<else>, } ] (s20)
[ 6: statement -> . whileStatement <;>, { <;>,<else>, } ] (s22)
[ 7: statement -> . <{> statementList <}>, { <;>,<else>, } ] (s24)
[ 8: statement -> . exprList <;>, { <;>,<else>, } ] (s27)
[ 9: statement -> . <;>, { <;>,<else>, } ] (s29)
[ 11: ifStatement -> . <if> @1 <(> exprList <)> statement elseStatement, { <;>, } ] (s9)
[ 15: forStatement -> . <for> <(> forExpr <;> exprList <;> exprList <;> <)> statement, { <;>, } ] (s30)
[ 14: whileStatement -> . <while> <(> exprList <)> statement, { <;>, } ] (s41)
[ 17: exprList -> . exprList <,> assignExpr, { <,>,<;>, } ] (s27)
[ 18: exprList -> . assignExpr, { <,>,<;>, } ] (s61)
[ 19: assignExpr -> . assignExpr assignOptr conditionalExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s61)
[ 20: assignExpr -> . conditionalExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s92)
[ 26: conditionalExpr -> . binaryExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s95)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s96)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s97)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s72)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s73)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s74)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s81)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s82)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s83)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s99)
[ 46: lambdaHead -> . <id>, { <arrow>, } ] (s72)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow>, } ] (s74)

i14
[ 11: ifStatement -> <if> @1 <(> exprList <)> statement . elseStatement, { <;>, } ]* (s15)
[ 12: elseStatement -> . <else> statement, { <;>, } ] (s16)
[ 13: elseStatement -> ., { <;>, } ] (r)

i15
[ 11: ifStatement -> <if> @1 <(> exprList <)> statement elseStatement ., { <;>, } ]* (r)

i16
[ 12: elseStatement -> <else> . statement, { <;>, } ]* (s17)
[ 4: statement -> . ifStatement <;>, { <;>, } ] (s18)
[ 5: statement -> . forStatement <;>, { <;>, } ] (s20)
[ 6: statement -> . whileStatement <;>, { <;>, } ] (s22)
[ 7: statement -> . <{> statementList <}>, { <;>, } ] (s24)
[ 8: statement -> . exprList <;>, { <;>, } ] (s27)
[ 9: statement -> . <;>, { <;>, } ] (s29)
[ 11: ifStatement -> . <if> @1 <(> exprList <)> statement elseStatement, { <;>, } ] (s9)
[ 15: forStatement -> . <for> <(> forExpr <;> exprList <;> exprList <;> <)> statement, { <;>, } ] (s30)
[ 14: whileStatement -> . <while> <(> exprList <)> statement, { <;>, } ] (s41)
[ 17: exprList -> . exprList <,> assignExpr, { <,>,<;>, } ] (s27)
[ 18: exprList -> . assignExpr, { <,>,<;>, } ] (s61)
[ 19: assignExpr -> . assignExpr assignOptr conditionalExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s61)
[ 20: assignExpr -> . conditionalExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s92)
[ 26: conditionalExpr -> . binaryExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s95)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s96)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s97)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s72)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s73)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s74)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s81)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s82)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s83)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s99)
[ 46: lambdaHead -> . <id>, { <arrow>, } ] (s72)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow>, } ] (s74)

i17
[ 12: elseStatement -> <else> statement ., { <;>, } ]* (r)

i18
[ 4: statement -> ifStatement . <;>, { <EOF>,<(>,<id>,<num>,<;>,<{>,<}>,<if>,<else>,<while>,<for>,<function>, } ]* (s19)

i19
[ 4: statement -> ifStatement <;> ., { <EOF>,<(>,<id>,<num>,<;>,<{>,<}>,<if>,<else>,<while>,<for>,<function>, } ]* (r)

i20
[ 5: statement -> forStatement . <;>, { <EOF>,<(>,<id>,<num>,<;>,<{>,<}>,<if>,<else>,<while>,<for>,<function>, } ]* (s21)

i21
[ 5: statement -> forStatement <;> ., { <EOF>,<(>,<id>,<num>,<;>,<{>,<}>,<if>,<else>,<while>,<for>,<function>, } ]* (r)

i22
[ 6: statement -> whileStatement . <;>, { <EOF>,<(>,<id>,<num>,<;>,<{>,<}>,<if>,<else>,<while>,<for>,<function>, } ]* (s23)

i23
[ 6: statement -> whileStatement <;> ., { <EOF>,<(>,<id>,<num>,<;>,<{>,<}>,<if>,<else>,<while>,<for>,<function>, } ]* (r)

i24
[ 7: statement -> <{> . statementList <}>, { <EOF>,<(>,<id>,<num>,<;>,<{>,<}>,<if>,<else>,<while>,<for>,<function>, } ]* (s25)
[ 2: statementList -> . statementList statement, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function>, } ] (s25)
[ 3: statementList -> ., { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function>, } ] (r)

i25
[ 7: statement -> <{> statementList . <}>, { <EOF>,<(>,<id>,<num>,<;>,<{>,<}>,<if>,<else>,<while>,<for>,<function>, } ]* (s26)
[ 2: statementList -> statementList . statement, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function>, } ]* (s3)
[ 4: statement -> . ifStatement <;>, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function>, } ] (s18)
[ 5: statement -> . forStatement <;>, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function>, } ] (s20)
[ 6: statement -> . whileStatement <;>, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function>, } ] (s22)
[ 7: statement -> . <{> statementList <}>, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function>, } ] (s24)
[ 8: statement -> . exprList <;>, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function>, } ] (s27)
[ 9: statement -> . <;>, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function>, } ] (s29)
[ 11: ifStatement -> . <if> @1 <(> exprList <)> statement elseStatement, { <;>, } ] (s9)
[ 15: forStatement -> . <for> <(> forExpr <;> exprList <;> exprList <;> <)> statement, { <;>, } ] (s30)
[ 14: whileStatement -> . <while> <(> exprList <)> statement, { <;>, } ] (s41)
[ 17: exprList -> . exprList <,> assignExpr, { <,>,<;>, } ] (s27)
[ 18: exprList -> . assignExpr, { <,>,<;>, } ] (s61)
[ 19: assignExpr -> . assignExpr assignOptr conditionalExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s61)
[ 20: assignExpr -> . conditionalExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s92)
[ 26: conditionalExpr -> . binaryExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s95)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s96)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s97)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s72)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s73)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s74)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s81)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s82)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s83)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s99)
[ 46: lambdaHead -> . <id>, { <arrow>, } ] (s72)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow>, } ] (s74)

i26
[ 7: statement -> <{> statementList <}> ., { <EOF>,<(>,<id>,<num>,<;>,<{>,<}>,<if>,<else>,<while>,<for>,<function>, } ]* (r)

i27
[ 8: statement -> exprList . <;>, { <EOF>,<(>,<id>,<num>,<;>,<{>,<}>,<if>,<else>,<while>,<for>,<function>, } ]* (s28)
[ 17: exprList -> exprList . <,> assignExpr, { <,>,<;>, } ]* (s77)

i28
[ 8: statement -> exprList <;> ., { <EOF>,<(>,<id>,<num>,<;>,<{>,<}>,<if>,<else>,<while>,<for>,<function>, } ]* (r)

i29
[ 9: statement -> <;> ., { <EOF>,<(>,<id>,<num>,<;>,<{>,<}>,<if>,<else>,<while>,<for>,<function>, } ]* (r)

i30
[ 15: forStatement -> <for> . <(> forExpr <;> exprList <;> exprList <;> <)> statement, { <;>, } ]* (s31)

i31
[ 15: forStatement -> <for> <(> . forExpr <;> exprList <;> exprList <;> <)> statement, { <;>, } ]* (s32)
[ 16: forExpr -> . assignExpr, { <;>, } ] (s40)
[ 19: assignExpr -> . assignExpr assignOptr conditionalExpr, { <;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s40)
[ 20: assignExpr -> . conditionalExpr, { <;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s92)
[ 26: conditionalExpr -> . binaryExpr, { <;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s95)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s96)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s97)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s72)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s73)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s74)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s81)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s82)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s83)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s99)
[ 46: lambdaHead -> . <id>, { <arrow>, } ] (s72)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow>, } ] (s74)

i32
[ 15: forStatement -> <for> <(> forExpr . <;> exprList <;> exprList <;> <)> statement, { <;>, } ]* (s33)

i33
[ 15: forStatement -> <for> <(> forExpr <;> . exprList <;> exprList <;> <)> statement, { <;>, } ]* (s34)
[ 17: exprList -> . exprList <,> assignExpr, { <,>,<;>, } ] (s34)
[ 18: exprList -> . assignExpr, { <,>,<;>, } ] (s61)
[ 19: assignExpr -> . assignExpr assignOptr conditionalExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s61)
[ 20: assignExpr -> . conditionalExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s92)
[ 26: conditionalExpr -> . binaryExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s95)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s96)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s97)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s72)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s73)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s74)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s81)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s82)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s83)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s99)
[ 46: lambdaHead -> . <id>, { <arrow>, } ] (s72)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow>, } ] (s74)

i34
[ 15: forStatement -> <for> <(> forExpr <;> exprList . <;> exprList <;> <)> statement, { <;>, } ]* (s35)
[ 17: exprList -> exprList . <,> assignExpr, { <,>,<;>, } ]* (s77)

i35
[ 15: forStatement -> <for> <(> forExpr <;> exprList <;> . exprList <;> <)> statement, { <;>, } ]* (s36)
[ 17: exprList -> . exprList <,> assignExpr, { <,>,<;>, } ] (s36)
[ 18: exprList -> . assignExpr, { <,>,<;>, } ] (s61)
[ 19: assignExpr -> . assignExpr assignOptr conditionalExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s61)
[ 20: assignExpr -> . conditionalExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s92)
[ 26: conditionalExpr -> . binaryExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s95)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s96)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s97)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s72)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s73)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s74)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s81)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s82)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s83)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s99)
[ 46: lambdaHead -> . <id>, { <arrow>, } ] (s72)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow>, } ] (s74)

i36
[ 15: forStatement -> <for> <(> forExpr <;> exprList <;> exprList . <;> <)> statement, { <;>, } ]* (s37)
[ 17: exprList -> exprList . <,> assignExpr, { <,>,<;>, } ]* (s77)

i37
[ 15: forStatement -> <for> <(> forExpr <;> exprList <;> exprList <;> . <)> statement, { <;>, } ]* (s38)

i38
[ 15: forStatement -> <for> <(> forExpr <;> exprList <;> exprList <;> <)> . statement, { <;>, } ]* (s39)
[ 4: statement -> . ifStatement <;>, { <;>, } ] (s18)
[ 5: statement -> . forStatement <;>, { <;>, } ] (s20)
[ 6: statement -> . whileStatement <;>, { <;>, } ] (s22)
[ 7: statement -> . <{> statementList <}>, { <;>, } ] (s24)
[ 8: statement -> . exprList <;>, { <;>, } ] (s27)
[ 9: statement -> . <;>, { <;>, } ] (s29)
[ 11: ifStatement -> . <if> @1 <(> exprList <)> statement elseStatement, { <;>, } ] (s9)
[ 15: forStatement -> . <for> <(> forExpr <;> exprList <;> exprList <;> <)> statement, { <;>, } ] (s30)
[ 14: whileStatement -> . <while> <(> exprList <)> statement, { <;>, } ] (s41)
[ 17: exprList -> . exprList <,> assignExpr, { <,>,<;>, } ] (s27)
[ 18: exprList -> . assignExpr, { <,>,<;>, } ] (s61)
[ 19: assignExpr -> . assignExpr assignOptr conditionalExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s61)
[ 20: assignExpr -> . conditionalExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s92)
[ 26: conditionalExpr -> . binaryExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s95)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s96)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s97)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s72)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s73)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s74)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s81)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s82)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s83)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s99)
[ 46: lambdaHead -> . <id>, { <arrow>, } ] (s72)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow>, } ] (s74)

i39
[ 15: forStatement -> <for> <(> forExpr <;> exprList <;> exprList <;> <)> statement ., { <;>, } ]* (r)

i40
[ 16: forExpr -> assignExpr ., { <;>, } ]* (r)
[ 19: assignExpr -> assignExpr . assignOptr conditionalExpr, { <;>,<=>,<+=>,<-=>,<*=>,</=>, } ]* (s87)
[ 21: assignOptr -> . <=>, { <(>,<id>,<num>,<function>, } ] (s4)
[ 22: assignOptr -> . <+=>, { <(>,<id>,<num>,<function>, } ] (s5)
[ 23: assignOptr -> . <-=>, { <(>,<id>,<num>,<function>, } ] (s6)
[ 24: assignOptr -> . <*=>, { <(>,<id>,<num>,<function>, } ] (s7)
[ 25: assignOptr -> . </=>, { <(>,<id>,<num>,<function>, } ] (s8)

i41
[ 14: whileStatement -> <while> . <(> exprList <)> statement, { <;>, } ]* (s42)

i42
[ 14: whileStatement -> <while> <(> . exprList <)> statement, { <;>, } ]* (s43)
[ 17: exprList -> . exprList <,> assignExpr, { <)>,<,>, } ] (s43)
[ 18: exprList -> . assignExpr, { <)>,<,>, } ] (s61)
[ 19: assignExpr -> . assignExpr assignOptr conditionalExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s61)
[ 20: assignExpr -> . conditionalExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s92)
[ 26: conditionalExpr -> . binaryExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s95)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s96)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s97)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s72)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s73)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s74)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s81)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s82)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s83)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s99)
[ 46: lambdaHead -> . <id>, { <arrow>, } ] (s72)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow>, } ] (s74)

i43
[ 14: whileStatement -> <while> <(> exprList . <)> statement, { <;>, } ]* (s44)
[ 17: exprList -> exprList . <,> assignExpr, { <)>,<,>, } ]* (s77)

i44
[ 14: whileStatement -> <while> <(> exprList <)> . statement, { <;>, } ]* (s45)
[ 4: statement -> . ifStatement <;>, { <;>, } ] (s18)
[ 5: statement -> . forStatement <;>, { <;>, } ] (s20)
[ 6: statement -> . whileStatement <;>, { <;>, } ] (s22)
[ 7: statement -> . <{> statementList <}>, { <;>, } ] (s24)
[ 8: statement -> . exprList <;>, { <;>, } ] (s27)
[ 9: statement -> . <;>, { <;>, } ] (s29)
[ 11: ifStatement -> . <if> @1 <(> exprList <)> statement elseStatement, { <;>, } ] (s9)
[ 15: forStatement -> . <for> <(> forExpr <;> exprList <;> exprList <;> <)> statement, { <;>, } ] (s30)
[ 14: whileStatement -> . <while> <(> exprList <)> statement, { <;>, } ] (s41)
[ 17: exprList -> . exprList <,> assignExpr, { <,>,<;>, } ] (s27)
[ 18: exprList -> . assignExpr, { <,>,<;>, } ] (s61)
[ 19: assignExpr -> . assignExpr assignOptr conditionalExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s61)
[ 20: assignExpr -> . conditionalExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s92)
[ 26: conditionalExpr -> . binaryExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s95)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s96)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s97)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s72)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s73)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s74)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s81)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s82)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s83)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s99)
[ 46: lambdaHead -> . <id>, { <arrow>, } ] (s72)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow>, } ] (s74)

i45
[ 14: whileStatement -> <while> <(> exprList <)> statement ., { <;>, } ]* (r)

i46
[ 27: conditionalExpr -> binaryExpr <?> . assignExpr <:> assignExpr, { <)>,<,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ]* (s47)
[ 19: assignExpr -> . assignExpr assignOptr conditionalExpr, { <:>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s47)
[ 20: assignExpr -> . conditionalExpr, { <:>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s92)
[ 26: conditionalExpr -> . binaryExpr, { <:>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <:>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,<?>,<:>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,<?>,<:>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,<?>,<:>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<?>,<:>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<?>,<:>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<?>,<:>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s95)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<?>,<:>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s96)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<?>,<:>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s97)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<?>,<:>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s72)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<?>,<:>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s73)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<?>,<:>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s74)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<?>,<:>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s81)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<?>,<:>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s82)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<?>,<:>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s83)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<?>,<:>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s99)
[ 46: lambdaHead -> . <id>, { <arrow>, } ] (s72)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow>, } ] (s74)

i47
[ 27: conditionalExpr -> binaryExpr <?> assignExpr . <:> assignExpr, { <)>,<,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ]* (s48)
[ 19: assignExpr -> assignExpr . assignOptr conditionalExpr, { <:>,<=>,<+=>,<-=>,<*=>,</=>, } ]* (s87)
[ 21: assignOptr -> . <=>, { <(>,<id>,<num>,<function>, } ] (s4)
[ 22: assignOptr -> . <+=>, { <(>,<id>,<num>,<function>, } ] (s5)
[ 23: assignOptr -> . <-=>, { <(>,<id>,<num>,<function>, } ] (s6)
[ 24: assignOptr -> . <*=>, { <(>,<id>,<num>,<function>, } ] (s7)
[ 25: assignOptr -> . </=>, { <(>,<id>,<num>,<function>, } ] (s8)

i48
[ 27: conditionalExpr -> binaryExpr <?> assignExpr <:> . assignExpr, { <)>,<,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ]* (s49)
[ 19: assignExpr -> . assignExpr assignOptr conditionalExpr, { <)>,<,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s49)
[ 20: assignExpr -> . conditionalExpr, { <)>,<,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s92)
[ 26: conditionalExpr -> . binaryExpr, { <)>,<,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <)>,<,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s95)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s96)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s97)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s72)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s73)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s74)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s81)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s82)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s83)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s99)
[ 46: lambdaHead -> . <id>, { <arrow>, } ] (s72)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow>, } ] (s74)

i49
[ 27: conditionalExpr -> binaryExpr <?> assignExpr <:> assignExpr ., { <)>,<,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ]* (r)
[ 19: assignExpr -> assignExpr . assignOptr conditionalExpr, { <)>,<,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ]* (s87)
[ 21: assignOptr -> . <=>, { <(>,<id>,<num>,<function>, } ] (s4)
[ 22: assignOptr -> . <+=>, { <(>,<id>,<num>,<function>, } ] (s5)
[ 23: assignOptr -> . <-=>, { <(>,<id>,<num>,<function>, } ] (s6)
[ 24: assignOptr -> . <*=>, { <(>,<id>,<num>,<function>, } ] (s7)
[ 25: assignOptr -> . </=>, { <(>,<id>,<num>,<function>, } ] (s8)

i50
[ 28: binaryExpr -> binaryExpr <+> . multiplyExpr, { <+>,<->,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ]* (s51)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s51)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s51)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s95)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s96)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s97)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s72)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s73)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s74)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s81)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s82)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s83)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s99)
[ 46: lambdaHead -> . <id>, { <arrow>, } ] (s72)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow>, } ] (s74)

i51
[ 28: binaryExpr -> binaryExpr <+> multiplyExpr ., { <+>,<->,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ]* (r)
[ 31: multiplyExpr -> multiplyExpr . <*> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ]* (s52)
[ 32: multiplyExpr -> multiplyExpr . </> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ]* (s54)

i52
[ 31: multiplyExpr -> multiplyExpr <*> . unaryExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ]* (s53)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s96)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s97)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s72)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s73)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s74)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s81)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s82)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s83)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s99)
[ 46: lambdaHead -> . <id>, { <arrow>, } ] (s72)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow>, } ] (s74)

i53
[ 31: multiplyExpr -> multiplyExpr <*> unaryExpr ., { <+>,<->,</>,<*>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ]* (r)

i54
[ 32: multiplyExpr -> multiplyExpr </> . unaryExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ]* (s55)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s96)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s97)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s72)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s73)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s74)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s81)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s82)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s83)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s99)
[ 46: lambdaHead -> . <id>, { <arrow>, } ] (s72)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow>, } ] (s74)

i55
[ 32: multiplyExpr -> multiplyExpr </> unaryExpr ., { <+>,<->,</>,<*>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ]* (r)

i56
[ 36: trailer -> trailer <[> . subscript <]>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ]* (s57)
[ 59: subscript -> . exprList, { <]>, } ] (s59)
[ 60: subscript -> ., { <]>, } ] (r)
[ 17: exprList -> . exprList <,> assignExpr, { <,>,<]>, } ] (s59)
[ 18: exprList -> . assignExpr, { <,>,<]>, } ] (s61)
[ 19: assignExpr -> . assignExpr assignOptr conditionalExpr, { <,>,<=>,<+=>,<-=>,<*=>,</=>,<]>, } ] (s61)
[ 20: assignExpr -> . conditionalExpr, { <,>,<=>,<+=>,<-=>,<*=>,</=>,<]>, } ] (s92)
[ 26: conditionalExpr -> . binaryExpr, { <,>,<=>,<+=>,<-=>,<*=>,</=>,<]>, } ] (s93)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <,>,<=>,<+=>,<-=>,<*=>,</=>,<]>, } ] (s93)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<]>, } ] (s93)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<]>, } ] (s93)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<]>, } ] (s94)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<]>, } ] (s94)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<]>, } ] (s94)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<]>, } ] (s95)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<]>, } ] (s96)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<]>, } ] (s97)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ] (s72)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ] (s73)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ] (s74)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ] (s81)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ] (s82)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ] (s83)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ] (s99)
[ 46: lambdaHead -> . <id>, { <arrow>, } ] (s72)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow>, } ] (s74)

i57
[ 36: trailer -> trailer <[> subscript . <]>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ]* (s58)

i58
[ 36: trailer -> trailer <[> subscript <]> ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ]* (r)

i59
[ 59: subscript -> exprList ., { <]>, } ]* (r)
[ 17: exprList -> exprList . <,> assignExpr, { <,>,<]>, } ]* (s77)

i60
[ 17: exprList -> exprList <,> assignExpr ., { <)>,<,>,<;>,<]>, } ]* (r)
[ 19: assignExpr -> assignExpr . assignOptr conditionalExpr, { <)>,<,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ]* (s87)
[ 21: assignOptr -> . <=>, { <(>,<id>,<num>,<function>, } ] (s4)
[ 22: assignOptr -> . <+=>, { <(>,<id>,<num>,<function>, } ] (s5)
[ 23: assignOptr -> . <-=>, { <(>,<id>,<num>,<function>, } ] (s6)
[ 24: assignOptr -> . <*=>, { <(>,<id>,<num>,<function>, } ] (s7)
[ 25: assignOptr -> . </=>, { <(>,<id>,<num>,<function>, } ] (s8)

i61
[ 18: exprList -> assignExpr ., { <)>,<,>,<;>,<]>, } ]* (r)
[ 19: assignExpr -> assignExpr . assignOptr conditionalExpr, { <)>,<,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ]* (s87)
[ 21: assignOptr -> . <=>, { <(>,<id>,<num>,<function>, } ] (s4)
[ 22: assignOptr -> . <+=>, { <(>,<id>,<num>,<function>, } ] (s5)
[ 23: assignOptr -> . <-=>, { <(>,<id>,<num>,<function>, } ] (s6)
[ 24: assignOptr -> . <*=>, { <(>,<id>,<num>,<function>, } ] (s7)
[ 25: assignOptr -> . </=>, { <(>,<id>,<num>,<function>, } ] (s8)

i62
[ 37: trailer -> trailer <(> . argList <)>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ]* (s63)
[ 50: argList -> . nonEmptyArgList, { <)>, } ] (s65)
[ 51: argList -> ., { <)>, } ] (r)
[ 52: nonEmptyArgList -> . nonEmptyArgList <,> assignExpr, { <)>,<,>, } ] (s65)
[ 53: nonEmptyArgList -> . assignExpr, { <)>,<,>, } ] (s68)
[ 19: assignExpr -> . assignExpr assignOptr conditionalExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s68)
[ 20: assignExpr -> . conditionalExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s92)
[ 26: conditionalExpr -> . binaryExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s95)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s96)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s97)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s72)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s73)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s74)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s81)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s82)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s83)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s99)
[ 46: lambdaHead -> . <id>, { <arrow>, } ] (s72)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow>, } ] (s74)

i63
[ 37: trailer -> trailer <(> argList . <)>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ]* (s64)

i64
[ 37: trailer -> trailer <(> argList <)> ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ]* (r)

i65
[ 50: argList -> nonEmptyArgList ., { <)>, } ]* (r)
[ 52: nonEmptyArgList -> nonEmptyArgList . <,> assignExpr, { <)>,<,>, } ]* (s66)

i66
[ 52: nonEmptyArgList -> nonEmptyArgList <,> . assignExpr, { <)>,<,>, } ]* (s67)
[ 19: assignExpr -> . assignExpr assignOptr conditionalExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s67)
[ 20: assignExpr -> . conditionalExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s92)
[ 26: conditionalExpr -> . binaryExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s95)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s96)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s97)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s72)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s73)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s74)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s81)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s82)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s83)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s99)
[ 46: lambdaHead -> . <id>, { <arrow>, } ] (s72)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow>, } ] (s74)

i67
[ 52: nonEmptyArgList -> nonEmptyArgList <,> assignExpr ., { <)>,<,>, } ]* (r)
[ 19: assignExpr -> assignExpr . assignOptr conditionalExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=>, } ]* (s87)
[ 21: assignOptr -> . <=>, { <(>,<id>,<num>,<function>, } ] (s4)
[ 22: assignOptr -> . <+=>, { <(>,<id>,<num>,<function>, } ] (s5)
[ 23: assignOptr -> . <-=>, { <(>,<id>,<num>,<function>, } ] (s6)
[ 24: assignOptr -> . <*=>, { <(>,<id>,<num>,<function>, } ] (s7)
[ 25: assignOptr -> . </=>, { <(>,<id>,<num>,<function>, } ] (s8)

i68
[ 53: nonEmptyArgList -> assignExpr ., { <)>,<,>, } ]* (r)
[ 19: assignExpr -> assignExpr . assignOptr conditionalExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=>, } ]* (s87)
[ 21: assignOptr -> . <=>, { <(>,<id>,<num>,<function>, } ] (s4)
[ 22: assignOptr -> . <+=>, { <(>,<id>,<num>,<function>, } ] (s5)
[ 23: assignOptr -> . <-=>, { <(>,<id>,<num>,<function>, } ] (s6)
[ 24: assignOptr -> . <*=>, { <(>,<id>,<num>,<function>, } ] (s7)
[ 25: assignOptr -> . </=>, { <(>,<id>,<num>,<function>, } ] (s8)

i69
[ 29: binaryExpr -> binaryExpr <-> . multiplyExpr, { <+>,<->,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ]* (s70)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s70)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s70)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s95)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s96)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s97)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s72)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s73)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s74)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s81)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s82)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s83)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s99)
[ 46: lambdaHead -> . <id>, { <arrow>, } ] (s72)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow>, } ] (s74)

i70
[ 29: binaryExpr -> binaryExpr <-> multiplyExpr ., { <+>,<->,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ]* (r)
[ 31: multiplyExpr -> multiplyExpr . <*> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ]* (s52)
[ 32: multiplyExpr -> multiplyExpr . </> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ]* (s54)

i71
[ 38: trailer -> trailer <member> ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ]* (r)

i72
[ 40: atom -> <id> ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (r)
[ 46: lambdaHead -> <id> ., { <arrow>, } ]* (r)

i73
[ 41: atom -> <num> ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (r)

i74
[ 42: atom -> <(> . exprList <)>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (s75)
[ 47: lambdaHead -> <(> . argList <)>, { <arrow>, } ]* (s78)
[ 17: exprList -> . exprList <,> assignExpr, { <)>,<,>, } ] (s75)
[ 18: exprList -> . assignExpr, { <)>,<,>, } ] (s80)
[ 50: argList -> . nonEmptyArgList, { <)>, } ] (s65)
[ 51: argList -> ., { <)>, } ] (r)
[ 19: assignExpr -> . assignExpr assignOptr conditionalExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s80)
[ 20: assignExpr -> . conditionalExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s92)
[ 52: nonEmptyArgList -> . nonEmptyArgList <,> assignExpr, { <)>,<,>, } ] (s65)
[ 53: nonEmptyArgList -> . assignExpr, { <)>,<,>, } ] (s80)
[ 26: conditionalExpr -> . binaryExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s95)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s96)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s97)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s72)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s73)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s74)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s81)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s82)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s83)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s99)
[ 46: lambdaHead -> . <id>, { <arrow>, } ] (s72)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow>, } ] (s74)

i75
[ 42: atom -> <(> exprList . <)>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (s76)
[ 17: exprList -> exprList . <,> assignExpr, { <)>,<,>, } ]* (s77)

i76
[ 42: atom -> <(> exprList <)> ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (r)

i77
[ 17: exprList -> exprList <,> . assignExpr, { <)>,<,>,<;>,<]>, } ]* (s60)
[ 19: assignExpr -> . assignExpr assignOptr conditionalExpr, { <)>,<,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s60)
[ 20: assignExpr -> . conditionalExpr, { <)>,<,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s92)
[ 26: conditionalExpr -> . binaryExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s95)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s96)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s97)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s72)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s73)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s74)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s81)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s82)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s83)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s99)
[ 46: lambdaHead -> . <id>, { <arrow>, } ] (s72)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow>, } ] (s74)

i78
[ 47: lambdaHead -> <(> argList . <)>, { <arrow>, } ]* (s79)

i79
[ 47: lambdaHead -> <(> argList <)> ., { <arrow>, } ]* (r)

i80
[ 18: exprList -> assignExpr ., { <)>,<,>, } ]* (r)
[ 19: assignExpr -> assignExpr . assignOptr conditionalExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=>, } ]* (s87)
[ 53: nonEmptyArgList -> assignExpr ., { <)>,<,>, } ]* (r)
[ 21: assignOptr -> . <=>, { <(>,<id>,<num>,<function>, } ] (s4)
[ 22: assignOptr -> . <+=>, { <(>,<id>,<num>,<function>, } ] (s5)
[ 23: assignOptr -> . <-=>, { <(>,<id>,<num>,<function>, } ] (s6)
[ 24: assignOptr -> . <*=>, { <(>,<id>,<num>,<function>, } ] (s7)
[ 25: assignOptr -> . </=>, { <(>,<id>,<num>,<function>, } ] (s8)

i81
[ 43: atom -> lambda ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (r)

i82
[ 44: atom -> aFunction ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (r)

i83
[ 45: lambda -> lambdaHead . <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (s84)

i84
[ 45: lambda -> lambdaHead <arrow> . lambdaBody, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (s85)
[ 48: lambdaBody -> . assignExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ] (s86)
[ 49: lambdaBody -> . <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ] (s89)
[ 19: assignExpr -> . assignExpr assignOptr conditionalExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ] (s86)
[ 20: assignExpr -> . conditionalExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ] (s92)
[ 26: conditionalExpr -> . binaryExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ] (s93)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ] (s93)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ] (s93)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ] (s93)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ] (s94)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ] (s94)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ] (s94)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ] (s95)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ] (s96)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ] (s97)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ] (s72)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ] (s73)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ] (s74)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ] (s81)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ] (s82)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ] (s83)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ] (s99)
[ 46: lambdaHead -> . <id>, { <arrow>, } ] (s72)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow>, } ] (s74)

i85
[ 45: lambda -> lambdaHead <arrow> lambdaBody ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (r)

i86
[ 48: lambdaBody -> assignExpr ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (r)
[ 19: assignExpr -> assignExpr . assignOptr conditionalExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (s87)
[ 21: assignOptr -> . <=>, { <(>,<id>,<num>,<function>, } ] (s4)
[ 22: assignOptr -> . <+=>, { <(>,<id>,<num>,<function>, } ] (s5)
[ 23: assignOptr -> . <-=>, { <(>,<id>,<num>,<function>, } ] (s6)
[ 24: assignOptr -> . <*=>, { <(>,<id>,<num>,<function>, } ] (s7)
[ 25: assignOptr -> . </=>, { <(>,<id>,<num>,<function>, } ] (s8)

i87
[ 19: assignExpr -> assignExpr assignOptr . conditionalExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (s88)
[ 26: conditionalExpr -> . binaryExpr, { <)>,<,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <)>,<,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s95)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s96)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s97)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s72)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s73)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s74)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s81)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s82)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s83)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s99)
[ 46: lambdaHead -> . <id>, { <arrow>, } ] (s72)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow>, } ] (s74)

i88
[ 19: assignExpr -> assignExpr assignOptr conditionalExpr ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (r)

i89
[ 49: lambdaBody -> <{> . statementList <}>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (s90)
[ 2: statementList -> . statementList statement, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function>, } ] (s90)
[ 3: statementList -> ., { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function>, } ] (r)

i90
[ 49: lambdaBody -> <{> statementList . <}>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (s91)
[ 2: statementList -> statementList . statement, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function>, } ]* (s3)
[ 4: statement -> . ifStatement <;>, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function>, } ] (s18)
[ 5: statement -> . forStatement <;>, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function>, } ] (s20)
[ 6: statement -> . whileStatement <;>, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function>, } ] (s22)
[ 7: statement -> . <{> statementList <}>, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function>, } ] (s24)
[ 8: statement -> . exprList <;>, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function>, } ] (s27)
[ 9: statement -> . <;>, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function>, } ] (s29)
[ 11: ifStatement -> . <if> @1 <(> exprList <)> statement elseStatement, { <;>, } ] (s9)
[ 15: forStatement -> . <for> <(> forExpr <;> exprList <;> exprList <;> <)> statement, { <;>, } ] (s30)
[ 14: whileStatement -> . <while> <(> exprList <)> statement, { <;>, } ] (s41)
[ 17: exprList -> . exprList <,> assignExpr, { <,>,<;>, } ] (s27)
[ 18: exprList -> . assignExpr, { <,>,<;>, } ] (s61)
[ 19: assignExpr -> . assignExpr assignOptr conditionalExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s61)
[ 20: assignExpr -> . conditionalExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s92)
[ 26: conditionalExpr -> . binaryExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s95)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s96)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s97)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s72)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s73)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s74)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s81)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s82)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s83)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s99)
[ 46: lambdaHead -> . <id>, { <arrow>, } ] (s72)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow>, } ] (s74)

i91
[ 49: lambdaBody -> <{> statementList <}> ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (r)

i92
[ 20: assignExpr -> conditionalExpr ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (r)

i93
[ 26: conditionalExpr -> binaryExpr ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (r)
[ 27: conditionalExpr -> binaryExpr . <?> assignExpr <:> assignExpr, { <)>,<,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ]* (s46)
[ 28: binaryExpr -> binaryExpr . <+> multiplyExpr, { <+>,<->,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ]* (s50)
[ 29: binaryExpr -> binaryExpr . <-> multiplyExpr, { <+>,<->,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ]* (s69)

i94
[ 30: binaryExpr -> multiplyExpr ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (r)
[ 31: multiplyExpr -> multiplyExpr . <*> unaryExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ]* (s52)
[ 32: multiplyExpr -> multiplyExpr . </> unaryExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ]* (s54)

i95
[ 33: multiplyExpr -> unaryExpr ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (r)

i96
[ 34: unaryExpr -> atomicExpr ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (r)

i97
[ 35: atomicExpr -> atom . trailer, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (s98)
[ 36: trailer -> . trailer <[> subscript <]>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s98)
[ 37: trailer -> . trailer <(> argList <)>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s98)
[ 38: trailer -> . trailer <member>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s98)
[ 39: trailer -> ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (r)

i98
[ 35: atomicExpr -> atom trailer ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (r)
[ 36: trailer -> trailer . <[> subscript <]>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ]* (s56)
[ 37: trailer -> trailer . <(> argList <)>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ]* (s62)
[ 38: trailer -> trailer . <member>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ]* (s71)

i99
[ 61: aFunction -> <function> . funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (s100)
[ 62: funcName -> . <id>, { <(>, } ] (s112)
[ 63: funcName -> ., { <(>, } ] (r)

i100
[ 61: aFunction -> <function> funcName . <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (s101)

i101
[ 61: aFunction -> <function> funcName <(> . argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (s102)
[ 54: argDefList -> . nonEmptyArgDefList, { <)>, } ] (s107)
[ 55: argDefList -> ., { <)>, } ] (r)
[ 56: nonEmptyArgDefList -> . nonEmptyArgDefList <,> argDef, { <)>,<,>, } ] (s107)
[ 57: nonEmptyArgDefList -> . argDef, { <)>,<,>, } ] (s110)
[ 58: argDef -> . <id>, { <)>,<,>, } ] (s111)

i102
[ 61: aFunction -> <function> funcName <(> argDefList . <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (s103)

i103
[ 61: aFunction -> <function> funcName <(> argDefList <)> . <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (s104)

i104
[ 61: aFunction -> <function> funcName <(> argDefList <)> <{> . statementList <}>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (s105)
[ 2: statementList -> . statementList statement, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function>, } ] (s105)
[ 3: statementList -> ., { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function>, } ] (r)

i105
[ 61: aFunction -> <function> funcName <(> argDefList <)> <{> statementList . <}>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (s106)
[ 2: statementList -> statementList . statement, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function>, } ]* (s3)
[ 4: statement -> . ifStatement <;>, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function>, } ] (s18)
[ 5: statement -> . forStatement <;>, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function>, } ] (s20)
[ 6: statement -> . whileStatement <;>, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function>, } ] (s22)
[ 7: statement -> . <{> statementList <}>, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function>, } ] (s24)
[ 8: statement -> . exprList <;>, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function>, } ] (s27)
[ 9: statement -> . <;>, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function>, } ] (s29)
[ 11: ifStatement -> . <if> @1 <(> exprList <)> statement elseStatement, { <;>, } ] (s9)
[ 15: forStatement -> . <for> <(> forExpr <;> exprList <;> exprList <;> <)> statement, { <;>, } ] (s30)
[ 14: whileStatement -> . <while> <(> exprList <)> statement, { <;>, } ] (s41)
[ 17: exprList -> . exprList <,> assignExpr, { <,>,<;>, } ] (s27)
[ 18: exprList -> . assignExpr, { <,>,<;>, } ] (s61)
[ 19: assignExpr -> . assignExpr assignOptr conditionalExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s61)
[ 20: assignExpr -> . conditionalExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s92)
[ 26: conditionalExpr -> . binaryExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s93)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s94)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s95)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s96)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>, } ] (s97)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s72)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s73)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s74)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s81)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s82)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s83)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member>, } ] (s99)
[ 46: lambdaHead -> . <id>, { <arrow>, } ] (s72)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow>, } ] (s74)

i106
[ 61: aFunction -> <function> funcName <(> argDefList <)> <{> statementList <}> ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member>, } ]* (r)

i107
[ 54: argDefList -> nonEmptyArgDefList ., { <)>, } ]* (r)
[ 56: nonEmptyArgDefList -> nonEmptyArgDefList . <,> argDef, { <)>,<,>, } ]* (s108)

i108
[ 56: nonEmptyArgDefList -> nonEmptyArgDefList <,> . argDef, { <)>,<,>, } ]* (s109)
[ 58: argDef -> . <id>, { <)>,<,>, } ] (s111)

i109
[ 56: nonEmptyArgDefList -> nonEmptyArgDefList <,> argDef ., { <)>,<,>, } ]* (r)

i110
[ 57: nonEmptyArgDefList -> argDef ., { <)>,<,>, } ]* (r)

i111
[ 58: argDef -> <id> ., { <)>,<,>, } ]* (r)

i112
[ 62: funcName -> <id> ., { <(>, } ]* (r)

