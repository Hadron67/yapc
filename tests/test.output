unused token(s):
    <!> (NOT)

state 68,reduce/reduce conflict:
    token: <)>
    used:[ 18: exprList -> assignExpr . ]* (r)
    discarded:[ 53: nonEmptyArgList -> assignExpr . ]* (r)

state 68,reduce/reduce conflict:
    token: <,>
    used:[ 18: exprList -> assignExpr . ]* (r)
    discarded:[ 53: nonEmptyArgList -> assignExpr . ]* (r)

state 91,shift/reduce conflict:
    token: </=>
    used:[ 25: assignOptr -> . </=> ] (s3)
    discarded:[ 48: lambdaBody -> assignExpr . ]* (r)

state 91,shift/reduce conflict:
    token: <*=>
    used:[ 24: assignOptr -> . <*=> ] (s4)
    discarded:[ 48: lambdaBody -> assignExpr . ]* (r)

state 91,shift/reduce conflict:
    token: <-=>
    used:[ 23: assignOptr -> . <-=> ] (s5)
    discarded:[ 48: lambdaBody -> assignExpr . ]* (r)

state 91,shift/reduce conflict:
    token: <+=>
    used:[ 22: assignOptr -> . <+=> ] (s6)
    discarded:[ 48: lambdaBody -> assignExpr . ]* (r)

state 91,shift/reduce conflict:
    token: <=>
    used:[ 21: assignOptr -> . <=> ] (s7)
    discarded:[ 48: lambdaBody -> assignExpr . ]* (r)

state 95,shift/reduce conflict:
    token: <?>
    used:[ 27: conditionalExpr -> binaryExpr . <?> assignExpr <:> assignExpr ]* (s96)
    discarded:[ 26: conditionalExpr -> binaryExpr . ]* (r)

state 95,shift/reduce conflict:
    token: <->
    used:[ 29: binaryExpr -> binaryExpr . <-> multiplyExpr ]* (s100)
    discarded:[ 26: conditionalExpr -> binaryExpr . ]* (r)

state 95,shift/reduce conflict:
    token: <+>
    used:[ 28: binaryExpr -> binaryExpr . <+> multiplyExpr ]* (s106)
    discarded:[ 26: conditionalExpr -> binaryExpr . ]* (r)

state 99,shift/reduce conflict:
    token: </=>
    used:[ 25: assignOptr -> . </=> ] (s3)
    discarded:[ 27: conditionalExpr -> binaryExpr <?> assignExpr <:> assignExpr . ]* (r)

state 99,shift/reduce conflict:
    token: <*=>
    used:[ 24: assignOptr -> . <*=> ] (s4)
    discarded:[ 27: conditionalExpr -> binaryExpr <?> assignExpr <:> assignExpr . ]* (r)

state 99,shift/reduce conflict:
    token: <-=>
    used:[ 23: assignOptr -> . <-=> ] (s5)
    discarded:[ 27: conditionalExpr -> binaryExpr <?> assignExpr <:> assignExpr . ]* (r)

state 99,shift/reduce conflict:
    token: <+=>
    used:[ 22: assignOptr -> . <+=> ] (s6)
    discarded:[ 27: conditionalExpr -> binaryExpr <?> assignExpr <:> assignExpr . ]* (r)

state 99,shift/reduce conflict:
    token: <=>
    used:[ 21: assignOptr -> . <=> ] (s7)
    discarded:[ 27: conditionalExpr -> binaryExpr <?> assignExpr <:> assignExpr . ]* (r)

state 101,shift/reduce conflict:
    token: </>
    used:[ 32: multiplyExpr -> multiplyExpr . </> unaryExpr ]* (s102)
    discarded:[ 29: binaryExpr -> binaryExpr <-> multiplyExpr . ]* (r)

state 101,shift/reduce conflict:
    token: <*>
    used:[ 31: multiplyExpr -> multiplyExpr . <*> unaryExpr ]* (s104)
    discarded:[ 29: binaryExpr -> binaryExpr <-> multiplyExpr . ]* (r)

state 107,shift/reduce conflict:
    token: </>
    used:[ 32: multiplyExpr -> multiplyExpr . </> unaryExpr ]* (s102)
    discarded:[ 28: binaryExpr -> binaryExpr <+> multiplyExpr . ]* (r)

state 107,shift/reduce conflict:
    token: <*>
    used:[ 31: multiplyExpr -> multiplyExpr . <*> unaryExpr ]* (s104)
    discarded:[ 28: binaryExpr -> binaryExpr <+> multiplyExpr . ]* (r)

state 108,shift/reduce conflict:
    token: </>
    used:[ 32: multiplyExpr -> multiplyExpr . </> unaryExpr ]* (s102)
    discarded:[ 30: binaryExpr -> multiplyExpr . ]* (r)

state 108,shift/reduce conflict:
    token: <*>
    used:[ 31: multiplyExpr -> multiplyExpr . <*> unaryExpr ]* (s104)
    discarded:[ 30: binaryExpr -> multiplyExpr . ]* (r)

state 112,shift/reduce conflict:
    token: <member>
    used:[ 38: trailer -> trailer . <member> ]* (s54)
    discarded:[ 35: atomicExpr -> atom trailer . ]* (r)

state 112,shift/reduce conflict:
    token: <(>
    used:[ 37: trailer -> trailer . <(> argList <)> ]* (s55)
    discarded:[ 35: atomicExpr -> atom trailer . ]* (r)

state 112,shift/reduce conflict:
    token: <[>
    used:[ 36: trailer -> trailer . <[> subscript <]> ]* (s58)
    discarded:[ 35: atomicExpr -> atom trailer . ]* (r)

warning: 24 conflict(s) detected.

i0
[ 0: (accept) -> . start, { <EOF> } ]* (s1)
[ 1: start -> . statementList, { <EOF> } ] (s2)
[ 3: statementList -> ., { <EOF>,<(>,<id>,<num>,<;>,<{>,<if>,<while>,<for>,<function> } ] (r)
[ 2: statementList -> . statementList statement, { <EOF>,<(>,<id>,<num>,<;>,<{>,<if>,<while>,<for>,<function> } ] (s2)

i1
[ 0: (accept) -> start ., { <EOF> } ]* (r)

i2
[ 1: start -> statementList ., { <EOF> } ]* (r)
[ 2: statementList -> statementList . statement, { <EOF>,<(>,<id>,<num>,<;>,<{>,<if>,<while>,<for>,<function> } ]* (s8)
[ 9: statement -> . <;>, { <EOF>,<(>,<id>,<num>,<;>,<{>,<if>,<while>,<for>,<function> } ] (s34)
[ 8: statement -> . exprList <;>, { <EOF>,<(>,<id>,<num>,<;>,<{>,<if>,<while>,<for>,<function> } ] (s35)
[ 7: statement -> . <{> statementList <}>, { <EOF>,<(>,<id>,<num>,<;>,<{>,<if>,<while>,<for>,<function> } ] (s37)
[ 6: statement -> . whileStatement <;>, { <EOF>,<(>,<id>,<num>,<;>,<{>,<if>,<while>,<for>,<function> } ] (s40)
[ 5: statement -> . forStatement <;>, { <EOF>,<(>,<id>,<num>,<;>,<{>,<if>,<while>,<for>,<function> } ] (s42)
[ 4: statement -> . ifStatement <;>, { <EOF>,<(>,<id>,<num>,<;>,<{>,<if>,<while>,<for>,<function> } ] (s44)
[ 18: exprList -> . assignExpr, { <,>,<;> } ] (s53)
[ 17: exprList -> . exprList <,> assignExpr, { <,>,<;> } ] (s35)
[ 14: whileStatement -> . <while> <(> exprList <)> statement, { <;> } ] (s9)
[ 15: forStatement -> . <for> <(> forExpr <;> exprList <;> exprList <;> <)> statement, { <;> } ] (s14)
[ 11: ifStatement -> . <if> @1 <(> exprList <)> statement elseStatement, { <;> } ] (s25)
[ 20: assignExpr -> . conditionalExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s94)
[ 19: assignExpr -> . assignExpr assignOptr conditionalExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s53)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 26: conditionalExpr -> . binaryExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s109)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s110)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s111)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s61)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s62)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s63)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s69)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s70)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s71)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s85)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow> } ] (s63)
[ 46: lambdaHead -> . <id>, { <arrow> } ] (s70)

i3
[ 25: assignOptr -> </=> ., { <(>,<id>,<num>,<function> } ]* (r)

i4
[ 24: assignOptr -> <*=> ., { <(>,<id>,<num>,<function> } ]* (r)

i5
[ 23: assignOptr -> <-=> ., { <(>,<id>,<num>,<function> } ]* (r)

i6
[ 22: assignOptr -> <+=> ., { <(>,<id>,<num>,<function> } ]* (r)

i7
[ 21: assignOptr -> <=> ., { <(>,<id>,<num>,<function> } ]* (r)

i8
[ 2: statementList -> statementList statement ., { <EOF>,<(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function> } ]* (r)

i9
[ 14: whileStatement -> <while> . <(> exprList <)> statement, { <;> } ]* (s10)

i10
[ 14: whileStatement -> <while> <(> . exprList <)> statement, { <;> } ]* (s11)
[ 18: exprList -> . assignExpr, { <)>,<,> } ] (s53)
[ 17: exprList -> . exprList <,> assignExpr, { <)>,<,> } ] (s11)
[ 20: assignExpr -> . conditionalExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=> } ] (s94)
[ 19: assignExpr -> . assignExpr assignOptr conditionalExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=> } ] (s53)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 26: conditionalExpr -> . binaryExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=> } ] (s109)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=> } ] (s110)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=> } ] (s111)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s61)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s62)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s63)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s69)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s70)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s71)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s85)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow> } ] (s63)
[ 46: lambdaHead -> . <id>, { <arrow> } ] (s70)

i11
[ 14: whileStatement -> <while> <(> exprList . <)> statement, { <;> } ]* (s12)
[ 17: exprList -> exprList . <,> assignExpr, { <)>,<,> } ]* (s51)

i12
[ 14: whileStatement -> <while> <(> exprList <)> . statement, { <;> } ]* (s13)
[ 9: statement -> . <;>, { <;> } ] (s34)
[ 8: statement -> . exprList <;>, { <;> } ] (s35)
[ 7: statement -> . <{> statementList <}>, { <;> } ] (s37)
[ 6: statement -> . whileStatement <;>, { <;> } ] (s40)
[ 5: statement -> . forStatement <;>, { <;> } ] (s42)
[ 4: statement -> . ifStatement <;>, { <;> } ] (s44)
[ 18: exprList -> . assignExpr, { <,>,<;> } ] (s53)
[ 17: exprList -> . exprList <,> assignExpr, { <,>,<;> } ] (s35)
[ 14: whileStatement -> . <while> <(> exprList <)> statement, { <;> } ] (s9)
[ 15: forStatement -> . <for> <(> forExpr <;> exprList <;> exprList <;> <)> statement, { <;> } ] (s14)
[ 11: ifStatement -> . <if> @1 <(> exprList <)> statement elseStatement, { <;> } ] (s25)
[ 20: assignExpr -> . conditionalExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s94)
[ 19: assignExpr -> . assignExpr assignOptr conditionalExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s53)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 26: conditionalExpr -> . binaryExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s109)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s110)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s111)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s61)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s62)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s63)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s69)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s70)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s71)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s85)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow> } ] (s63)
[ 46: lambdaHead -> . <id>, { <arrow> } ] (s70)

i13
[ 14: whileStatement -> <while> <(> exprList <)> statement ., { <;> } ]* (r)

i14
[ 15: forStatement -> <for> . <(> forExpr <;> exprList <;> exprList <;> <)> statement, { <;> } ]* (s15)

i15
[ 15: forStatement -> <for> <(> . forExpr <;> exprList <;> exprList <;> <)> statement, { <;> } ]* (s16)
[ 16: forExpr -> . assignExpr, { <;> } ] (s24)
[ 20: assignExpr -> . conditionalExpr, { <;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s94)
[ 19: assignExpr -> . assignExpr assignOptr conditionalExpr, { <;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s24)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 26: conditionalExpr -> . binaryExpr, { <;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s109)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s110)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s111)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s61)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s62)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s63)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s69)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s70)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s71)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s85)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow> } ] (s63)
[ 46: lambdaHead -> . <id>, { <arrow> } ] (s70)

i16
[ 15: forStatement -> <for> <(> forExpr . <;> exprList <;> exprList <;> <)> statement, { <;> } ]* (s17)

i17
[ 15: forStatement -> <for> <(> forExpr <;> . exprList <;> exprList <;> <)> statement, { <;> } ]* (s18)
[ 18: exprList -> . assignExpr, { <,>,<;> } ] (s53)
[ 17: exprList -> . exprList <,> assignExpr, { <,>,<;> } ] (s18)
[ 20: assignExpr -> . conditionalExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s94)
[ 19: assignExpr -> . assignExpr assignOptr conditionalExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s53)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 26: conditionalExpr -> . binaryExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s109)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s110)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s111)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s61)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s62)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s63)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s69)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s70)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s71)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s85)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow> } ] (s63)
[ 46: lambdaHead -> . <id>, { <arrow> } ] (s70)

i18
[ 15: forStatement -> <for> <(> forExpr <;> exprList . <;> exprList <;> <)> statement, { <;> } ]* (s19)
[ 17: exprList -> exprList . <,> assignExpr, { <,>,<;> } ]* (s51)

i19
[ 15: forStatement -> <for> <(> forExpr <;> exprList <;> . exprList <;> <)> statement, { <;> } ]* (s20)
[ 18: exprList -> . assignExpr, { <,>,<;> } ] (s53)
[ 17: exprList -> . exprList <,> assignExpr, { <,>,<;> } ] (s20)
[ 20: assignExpr -> . conditionalExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s94)
[ 19: assignExpr -> . assignExpr assignOptr conditionalExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s53)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 26: conditionalExpr -> . binaryExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s109)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s110)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s111)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s61)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s62)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s63)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s69)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s70)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s71)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s85)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow> } ] (s63)
[ 46: lambdaHead -> . <id>, { <arrow> } ] (s70)

i20
[ 15: forStatement -> <for> <(> forExpr <;> exprList <;> exprList . <;> <)> statement, { <;> } ]* (s21)
[ 17: exprList -> exprList . <,> assignExpr, { <,>,<;> } ]* (s51)

i21
[ 15: forStatement -> <for> <(> forExpr <;> exprList <;> exprList <;> . <)> statement, { <;> } ]* (s22)

i22
[ 15: forStatement -> <for> <(> forExpr <;> exprList <;> exprList <;> <)> . statement, { <;> } ]* (s23)
[ 9: statement -> . <;>, { <;> } ] (s34)
[ 8: statement -> . exprList <;>, { <;> } ] (s35)
[ 7: statement -> . <{> statementList <}>, { <;> } ] (s37)
[ 6: statement -> . whileStatement <;>, { <;> } ] (s40)
[ 5: statement -> . forStatement <;>, { <;> } ] (s42)
[ 4: statement -> . ifStatement <;>, { <;> } ] (s44)
[ 18: exprList -> . assignExpr, { <,>,<;> } ] (s53)
[ 17: exprList -> . exprList <,> assignExpr, { <,>,<;> } ] (s35)
[ 14: whileStatement -> . <while> <(> exprList <)> statement, { <;> } ] (s9)
[ 15: forStatement -> . <for> <(> forExpr <;> exprList <;> exprList <;> <)> statement, { <;> } ] (s14)
[ 11: ifStatement -> . <if> @1 <(> exprList <)> statement elseStatement, { <;> } ] (s25)
[ 20: assignExpr -> . conditionalExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s94)
[ 19: assignExpr -> . assignExpr assignOptr conditionalExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s53)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 26: conditionalExpr -> . binaryExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s109)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s110)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s111)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s61)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s62)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s63)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s69)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s70)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s71)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s85)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow> } ] (s63)
[ 46: lambdaHead -> . <id>, { <arrow> } ] (s70)

i23
[ 15: forStatement -> <for> <(> forExpr <;> exprList <;> exprList <;> <)> statement ., { <;> } ]* (r)

i24
[ 16: forExpr -> assignExpr ., { <;> } ]* (r)
[ 19: assignExpr -> assignExpr . assignOptr conditionalExpr, { <;>,<=>,<+=>,<-=>,<*=>,</=> } ]* (s92)
[ 25: assignOptr -> . </=>, { <(>,<id>,<num>,<function> } ] (s3)
[ 24: assignOptr -> . <*=>, { <(>,<id>,<num>,<function> } ] (s4)
[ 23: assignOptr -> . <-=>, { <(>,<id>,<num>,<function> } ] (s5)
[ 22: assignOptr -> . <+=>, { <(>,<id>,<num>,<function> } ] (s6)
[ 21: assignOptr -> . <=>, { <(>,<id>,<num>,<function> } ] (s7)

i25
[ 11: ifStatement -> <if> . @1 <(> exprList <)> statement elseStatement, { <;> } ]* (s26)
[ 10: @1 -> ., { <(> } ] (r)

i26
[ 11: ifStatement -> <if> @1 . <(> exprList <)> statement elseStatement, { <;> } ]* (s27)

i27
[ 11: ifStatement -> <if> @1 <(> . exprList <)> statement elseStatement, { <;> } ]* (s28)
[ 18: exprList -> . assignExpr, { <)>,<,> } ] (s53)
[ 17: exprList -> . exprList <,> assignExpr, { <)>,<,> } ] (s28)
[ 20: assignExpr -> . conditionalExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=> } ] (s94)
[ 19: assignExpr -> . assignExpr assignOptr conditionalExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=> } ] (s53)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 26: conditionalExpr -> . binaryExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=> } ] (s109)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=> } ] (s110)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=> } ] (s111)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s61)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s62)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s63)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s69)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s70)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s71)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s85)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow> } ] (s63)
[ 46: lambdaHead -> . <id>, { <arrow> } ] (s70)

i28
[ 11: ifStatement -> <if> @1 <(> exprList . <)> statement elseStatement, { <;> } ]* (s29)
[ 17: exprList -> exprList . <,> assignExpr, { <)>,<,> } ]* (s51)

i29
[ 11: ifStatement -> <if> @1 <(> exprList <)> . statement elseStatement, { <;> } ]* (s30)
[ 9: statement -> . <;>, { <;>,<else> } ] (s34)
[ 8: statement -> . exprList <;>, { <;>,<else> } ] (s35)
[ 7: statement -> . <{> statementList <}>, { <;>,<else> } ] (s37)
[ 6: statement -> . whileStatement <;>, { <;>,<else> } ] (s40)
[ 5: statement -> . forStatement <;>, { <;>,<else> } ] (s42)
[ 4: statement -> . ifStatement <;>, { <;>,<else> } ] (s44)
[ 18: exprList -> . assignExpr, { <,>,<;> } ] (s53)
[ 17: exprList -> . exprList <,> assignExpr, { <,>,<;> } ] (s35)
[ 14: whileStatement -> . <while> <(> exprList <)> statement, { <;> } ] (s9)
[ 15: forStatement -> . <for> <(> forExpr <;> exprList <;> exprList <;> <)> statement, { <;> } ] (s14)
[ 11: ifStatement -> . <if> @1 <(> exprList <)> statement elseStatement, { <;> } ] (s25)
[ 20: assignExpr -> . conditionalExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s94)
[ 19: assignExpr -> . assignExpr assignOptr conditionalExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s53)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 26: conditionalExpr -> . binaryExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s109)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s110)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s111)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s61)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s62)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s63)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s69)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s70)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s71)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s85)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow> } ] (s63)
[ 46: lambdaHead -> . <id>, { <arrow> } ] (s70)

i30
[ 11: ifStatement -> <if> @1 <(> exprList <)> statement . elseStatement, { <;> } ]* (s31)
[ 13: elseStatement -> ., { <;> } ] (r)
[ 12: elseStatement -> . <else> statement, { <;> } ] (s32)

i31
[ 11: ifStatement -> <if> @1 <(> exprList <)> statement elseStatement ., { <;> } ]* (r)

i32
[ 12: elseStatement -> <else> . statement, { <;> } ]* (s33)
[ 9: statement -> . <;>, { <;> } ] (s34)
[ 8: statement -> . exprList <;>, { <;> } ] (s35)
[ 7: statement -> . <{> statementList <}>, { <;> } ] (s37)
[ 6: statement -> . whileStatement <;>, { <;> } ] (s40)
[ 5: statement -> . forStatement <;>, { <;> } ] (s42)
[ 4: statement -> . ifStatement <;>, { <;> } ] (s44)
[ 18: exprList -> . assignExpr, { <,>,<;> } ] (s53)
[ 17: exprList -> . exprList <,> assignExpr, { <,>,<;> } ] (s35)
[ 14: whileStatement -> . <while> <(> exprList <)> statement, { <;> } ] (s9)
[ 15: forStatement -> . <for> <(> forExpr <;> exprList <;> exprList <;> <)> statement, { <;> } ] (s14)
[ 11: ifStatement -> . <if> @1 <(> exprList <)> statement elseStatement, { <;> } ] (s25)
[ 20: assignExpr -> . conditionalExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s94)
[ 19: assignExpr -> . assignExpr assignOptr conditionalExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s53)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 26: conditionalExpr -> . binaryExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s109)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s110)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s111)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s61)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s62)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s63)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s69)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s70)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s71)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s85)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow> } ] (s63)
[ 46: lambdaHead -> . <id>, { <arrow> } ] (s70)

i33
[ 12: elseStatement -> <else> statement ., { <;> } ]* (r)

i34
[ 9: statement -> <;> ., { <EOF>,<(>,<id>,<num>,<;>,<{>,<}>,<if>,<else>,<while>,<for>,<function> } ]* (r)

i35
[ 8: statement -> exprList . <;>, { <EOF>,<(>,<id>,<num>,<;>,<{>,<}>,<if>,<else>,<while>,<for>,<function> } ]* (s36)
[ 17: exprList -> exprList . <,> assignExpr, { <,>,<;> } ]* (s51)

i36
[ 8: statement -> exprList <;> ., { <EOF>,<(>,<id>,<num>,<;>,<{>,<}>,<if>,<else>,<while>,<for>,<function> } ]* (r)

i37
[ 7: statement -> <{> . statementList <}>, { <EOF>,<(>,<id>,<num>,<;>,<{>,<}>,<if>,<else>,<while>,<for>,<function> } ]* (s38)
[ 3: statementList -> ., { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function> } ] (r)
[ 2: statementList -> . statementList statement, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function> } ] (s38)

i38
[ 7: statement -> <{> statementList . <}>, { <EOF>,<(>,<id>,<num>,<;>,<{>,<}>,<if>,<else>,<while>,<for>,<function> } ]* (s39)
[ 2: statementList -> statementList . statement, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function> } ]* (s8)
[ 9: statement -> . <;>, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function> } ] (s34)
[ 8: statement -> . exprList <;>, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function> } ] (s35)
[ 7: statement -> . <{> statementList <}>, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function> } ] (s37)
[ 6: statement -> . whileStatement <;>, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function> } ] (s40)
[ 5: statement -> . forStatement <;>, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function> } ] (s42)
[ 4: statement -> . ifStatement <;>, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function> } ] (s44)
[ 18: exprList -> . assignExpr, { <,>,<;> } ] (s53)
[ 17: exprList -> . exprList <,> assignExpr, { <,>,<;> } ] (s35)
[ 14: whileStatement -> . <while> <(> exprList <)> statement, { <;> } ] (s9)
[ 15: forStatement -> . <for> <(> forExpr <;> exprList <;> exprList <;> <)> statement, { <;> } ] (s14)
[ 11: ifStatement -> . <if> @1 <(> exprList <)> statement elseStatement, { <;> } ] (s25)
[ 20: assignExpr -> . conditionalExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s94)
[ 19: assignExpr -> . assignExpr assignOptr conditionalExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s53)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 26: conditionalExpr -> . binaryExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s109)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s110)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s111)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s61)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s62)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s63)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s69)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s70)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s71)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s85)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow> } ] (s63)
[ 46: lambdaHead -> . <id>, { <arrow> } ] (s70)

i39
[ 7: statement -> <{> statementList <}> ., { <EOF>,<(>,<id>,<num>,<;>,<{>,<}>,<if>,<else>,<while>,<for>,<function> } ]* (r)

i40
[ 6: statement -> whileStatement . <;>, { <EOF>,<(>,<id>,<num>,<;>,<{>,<}>,<if>,<else>,<while>,<for>,<function> } ]* (s41)

i41
[ 6: statement -> whileStatement <;> ., { <EOF>,<(>,<id>,<num>,<;>,<{>,<}>,<if>,<else>,<while>,<for>,<function> } ]* (r)

i42
[ 5: statement -> forStatement . <;>, { <EOF>,<(>,<id>,<num>,<;>,<{>,<}>,<if>,<else>,<while>,<for>,<function> } ]* (s43)

i43
[ 5: statement -> forStatement <;> ., { <EOF>,<(>,<id>,<num>,<;>,<{>,<}>,<if>,<else>,<while>,<for>,<function> } ]* (r)

i44
[ 4: statement -> ifStatement . <;>, { <EOF>,<(>,<id>,<num>,<;>,<{>,<}>,<if>,<else>,<while>,<for>,<function> } ]* (s45)

i45
[ 4: statement -> ifStatement <;> ., { <EOF>,<(>,<id>,<num>,<;>,<{>,<}>,<if>,<else>,<while>,<for>,<function> } ]* (r)

i46
[ 50: argList -> nonEmptyArgList ., { <)> } ]* (r)
[ 52: nonEmptyArgList -> nonEmptyArgList . <,> assignExpr, { <)>,<,> } ]* (s47)

i47
[ 52: nonEmptyArgList -> nonEmptyArgList <,> . assignExpr, { <)>,<,> } ]* (s48)
[ 20: assignExpr -> . conditionalExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=> } ] (s94)
[ 19: assignExpr -> . assignExpr assignOptr conditionalExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=> } ] (s48)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 26: conditionalExpr -> . binaryExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=> } ] (s109)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=> } ] (s110)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=> } ] (s111)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s61)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s62)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s63)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s69)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s70)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s71)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s85)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow> } ] (s63)
[ 46: lambdaHead -> . <id>, { <arrow> } ] (s70)

i48
[ 52: nonEmptyArgList -> nonEmptyArgList <,> assignExpr ., { <)>,<,> } ]* (r)
[ 19: assignExpr -> assignExpr . assignOptr conditionalExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=> } ]* (s92)
[ 25: assignOptr -> . </=>, { <(>,<id>,<num>,<function> } ] (s3)
[ 24: assignOptr -> . <*=>, { <(>,<id>,<num>,<function> } ] (s4)
[ 23: assignOptr -> . <-=>, { <(>,<id>,<num>,<function> } ] (s5)
[ 22: assignOptr -> . <+=>, { <(>,<id>,<num>,<function> } ] (s6)
[ 21: assignOptr -> . <=>, { <(>,<id>,<num>,<function> } ] (s7)

i49
[ 53: nonEmptyArgList -> assignExpr ., { <)>,<,> } ]* (r)
[ 19: assignExpr -> assignExpr . assignOptr conditionalExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=> } ]* (s92)
[ 25: assignOptr -> . </=>, { <(>,<id>,<num>,<function> } ] (s3)
[ 24: assignOptr -> . <*=>, { <(>,<id>,<num>,<function> } ] (s4)
[ 23: assignOptr -> . <-=>, { <(>,<id>,<num>,<function> } ] (s5)
[ 22: assignOptr -> . <+=>, { <(>,<id>,<num>,<function> } ] (s6)
[ 21: assignOptr -> . <=>, { <(>,<id>,<num>,<function> } ] (s7)

i50
[ 59: subscript -> exprList ., { <]> } ]* (r)
[ 17: exprList -> exprList . <,> assignExpr, { <,>,<]> } ]* (s51)

i51
[ 17: exprList -> exprList <,> . assignExpr, { <)>,<,>,<;>,<]> } ]* (s52)
[ 20: assignExpr -> . conditionalExpr, { <)>,<,>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<]> } ] (s94)
[ 19: assignExpr -> . assignExpr assignOptr conditionalExpr, { <)>,<,>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<]> } ] (s52)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <)>,<,>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<]> } ] (s95)
[ 26: conditionalExpr -> . binaryExpr, { <)>,<,>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<]> } ] (s95)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<]> } ] (s108)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<]> } ] (s95)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<]> } ] (s95)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<]> } ] (s109)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<]> } ] (s108)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<]> } ] (s108)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<]> } ] (s110)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<]> } ] (s111)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s61)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s62)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s63)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s69)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s70)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s71)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s85)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow> } ] (s63)
[ 46: lambdaHead -> . <id>, { <arrow> } ] (s70)

i52
[ 17: exprList -> exprList <,> assignExpr ., { <)>,<,>,<;>,<]> } ]* (r)
[ 19: assignExpr -> assignExpr . assignOptr conditionalExpr, { <)>,<,>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<]> } ]* (s92)
[ 25: assignOptr -> . </=>, { <(>,<id>,<num>,<function> } ] (s3)
[ 24: assignOptr -> . <*=>, { <(>,<id>,<num>,<function> } ] (s4)
[ 23: assignOptr -> . <-=>, { <(>,<id>,<num>,<function> } ] (s5)
[ 22: assignOptr -> . <+=>, { <(>,<id>,<num>,<function> } ] (s6)
[ 21: assignOptr -> . <=>, { <(>,<id>,<num>,<function> } ] (s7)

i53
[ 18: exprList -> assignExpr ., { <)>,<,>,<;>,<]> } ]* (r)
[ 19: assignExpr -> assignExpr . assignOptr conditionalExpr, { <)>,<,>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<]> } ]* (s92)
[ 25: assignOptr -> . </=>, { <(>,<id>,<num>,<function> } ] (s3)
[ 24: assignOptr -> . <*=>, { <(>,<id>,<num>,<function> } ] (s4)
[ 23: assignOptr -> . <-=>, { <(>,<id>,<num>,<function> } ] (s5)
[ 22: assignOptr -> . <+=>, { <(>,<id>,<num>,<function> } ] (s6)
[ 21: assignOptr -> . <=>, { <(>,<id>,<num>,<function> } ] (s7)

i54
[ 38: trailer -> trailer <member> ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (r)

i55
[ 37: trailer -> trailer <(> . argList <)>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (s56)
[ 51: argList -> ., { <)> } ] (r)
[ 50: argList -> . nonEmptyArgList, { <)> } ] (s46)
[ 53: nonEmptyArgList -> . assignExpr, { <)>,<,> } ] (s49)
[ 52: nonEmptyArgList -> . nonEmptyArgList <,> assignExpr, { <)>,<,> } ] (s46)
[ 20: assignExpr -> . conditionalExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=> } ] (s94)
[ 19: assignExpr -> . assignExpr assignOptr conditionalExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=> } ] (s49)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 26: conditionalExpr -> . binaryExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=> } ] (s109)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=> } ] (s110)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=> } ] (s111)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s61)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s62)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s63)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s69)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s70)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s71)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s85)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow> } ] (s63)
[ 46: lambdaHead -> . <id>, { <arrow> } ] (s70)

i56
[ 37: trailer -> trailer <(> argList . <)>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (s57)

i57
[ 37: trailer -> trailer <(> argList <)> ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (r)

i58
[ 36: trailer -> trailer <[> . subscript <]>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (s59)
[ 60: subscript -> ., { <]> } ] (r)
[ 59: subscript -> . exprList, { <]> } ] (s50)
[ 18: exprList -> . assignExpr, { <,>,<]> } ] (s53)
[ 17: exprList -> . exprList <,> assignExpr, { <,>,<]> } ] (s50)
[ 20: assignExpr -> . conditionalExpr, { <,>,<=>,<+=>,<-=>,<*=>,</=>,<]> } ] (s94)
[ 19: assignExpr -> . assignExpr assignOptr conditionalExpr, { <,>,<=>,<+=>,<-=>,<*=>,</=>,<]> } ] (s53)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <,>,<=>,<+=>,<-=>,<*=>,</=>,<]> } ] (s95)
[ 26: conditionalExpr -> . binaryExpr, { <,>,<=>,<+=>,<-=>,<*=>,</=>,<]> } ] (s95)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<]> } ] (s108)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<]> } ] (s95)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<]> } ] (s95)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<]> } ] (s109)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<]> } ] (s108)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<]> } ] (s108)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<]> } ] (s110)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<]> } ] (s111)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s61)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s62)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s63)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s69)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s70)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s71)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s85)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow> } ] (s63)
[ 46: lambdaHead -> . <id>, { <arrow> } ] (s70)

i59
[ 36: trailer -> trailer <[> subscript . <]>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (s60)

i60
[ 36: trailer -> trailer <[> subscript <]> ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (r)

i61
[ 44: atom -> aFunction ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (r)

i62
[ 43: atom -> lambda ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (r)

i63
[ 42: atom -> <(> . exprList <)>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (s64)
[ 47: lambdaHead -> <(> . argList <)>, { <arrow> } ]* (s66)
[ 18: exprList -> . assignExpr, { <)>,<,> } ] (s68)
[ 17: exprList -> . exprList <,> assignExpr, { <)>,<,> } ] (s64)
[ 51: argList -> ., { <)> } ] (r)
[ 50: argList -> . nonEmptyArgList, { <)> } ] (s46)
[ 20: assignExpr -> . conditionalExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=> } ] (s94)
[ 19: assignExpr -> . assignExpr assignOptr conditionalExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=> } ] (s68)
[ 53: nonEmptyArgList -> . assignExpr, { <)>,<,> } ] (s68)
[ 52: nonEmptyArgList -> . nonEmptyArgList <,> assignExpr, { <)>,<,> } ] (s46)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 26: conditionalExpr -> . binaryExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=> } ] (s109)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=> } ] (s110)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=> } ] (s111)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s61)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s62)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s63)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s69)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s70)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s71)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s85)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow> } ] (s63)
[ 46: lambdaHead -> . <id>, { <arrow> } ] (s70)

i64
[ 42: atom -> <(> exprList . <)>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (s65)
[ 17: exprList -> exprList . <,> assignExpr, { <)>,<,> } ]* (s51)

i65
[ 42: atom -> <(> exprList <)> ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (r)

i66
[ 47: lambdaHead -> <(> argList . <)>, { <arrow> } ]* (s67)

i67
[ 47: lambdaHead -> <(> argList <)> ., { <arrow> } ]* (r)

i68
[ 18: exprList -> assignExpr ., { <)>,<,> } ]* (r)
[ 19: assignExpr -> assignExpr . assignOptr conditionalExpr, { <)>,<,>,<=>,<+=>,<-=>,<*=>,</=> } ]* (s92)
[ 53: nonEmptyArgList -> assignExpr ., { <)>,<,> } ]* (r)
[ 25: assignOptr -> . </=>, { <(>,<id>,<num>,<function> } ] (s3)
[ 24: assignOptr -> . <*=>, { <(>,<id>,<num>,<function> } ] (s4)
[ 23: assignOptr -> . <-=>, { <(>,<id>,<num>,<function> } ] (s5)
[ 22: assignOptr -> . <+=>, { <(>,<id>,<num>,<function> } ] (s6)
[ 21: assignOptr -> . <=>, { <(>,<id>,<num>,<function> } ] (s7)

i69
[ 41: atom -> <num> ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (r)

i70
[ 40: atom -> <id> ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (r)
[ 46: lambdaHead -> <id> ., { <arrow> } ]* (r)

i71
[ 61: aFunction -> <function> . funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (s72)
[ 63: funcName -> ., { <(> } ] (r)
[ 62: funcName -> . <id>, { <(> } ] (s84)

i72
[ 61: aFunction -> <function> funcName . <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (s73)

i73
[ 61: aFunction -> <function> funcName <(> . argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (s74)
[ 55: argDefList -> ., { <)> } ] (r)
[ 54: argDefList -> . nonEmptyArgDefList, { <)> } ] (s79)
[ 57: nonEmptyArgDefList -> . argDef, { <)>,<,> } ] (s82)
[ 56: nonEmptyArgDefList -> . nonEmptyArgDefList <,> argDef, { <)>,<,> } ] (s79)
[ 58: argDef -> . <id>, { <)>,<,> } ] (s83)

i74
[ 61: aFunction -> <function> funcName <(> argDefList . <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (s75)

i75
[ 61: aFunction -> <function> funcName <(> argDefList <)> . <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (s76)

i76
[ 61: aFunction -> <function> funcName <(> argDefList <)> <{> . statementList <}>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (s77)
[ 3: statementList -> ., { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function> } ] (r)
[ 2: statementList -> . statementList statement, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function> } ] (s77)

i77
[ 61: aFunction -> <function> funcName <(> argDefList <)> <{> statementList . <}>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (s78)
[ 2: statementList -> statementList . statement, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function> } ]* (s8)
[ 9: statement -> . <;>, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function> } ] (s34)
[ 8: statement -> . exprList <;>, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function> } ] (s35)
[ 7: statement -> . <{> statementList <}>, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function> } ] (s37)
[ 6: statement -> . whileStatement <;>, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function> } ] (s40)
[ 5: statement -> . forStatement <;>, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function> } ] (s42)
[ 4: statement -> . ifStatement <;>, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function> } ] (s44)
[ 18: exprList -> . assignExpr, { <,>,<;> } ] (s53)
[ 17: exprList -> . exprList <,> assignExpr, { <,>,<;> } ] (s35)
[ 14: whileStatement -> . <while> <(> exprList <)> statement, { <;> } ] (s9)
[ 15: forStatement -> . <for> <(> forExpr <;> exprList <;> exprList <;> <)> statement, { <;> } ] (s14)
[ 11: ifStatement -> . <if> @1 <(> exprList <)> statement elseStatement, { <;> } ] (s25)
[ 20: assignExpr -> . conditionalExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s94)
[ 19: assignExpr -> . assignExpr assignOptr conditionalExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s53)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 26: conditionalExpr -> . binaryExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s109)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s110)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s111)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s61)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s62)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s63)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s69)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s70)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s71)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s85)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow> } ] (s63)
[ 46: lambdaHead -> . <id>, { <arrow> } ] (s70)

i78
[ 61: aFunction -> <function> funcName <(> argDefList <)> <{> statementList <}> ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (r)

i79
[ 54: argDefList -> nonEmptyArgDefList ., { <)> } ]* (r)
[ 56: nonEmptyArgDefList -> nonEmptyArgDefList . <,> argDef, { <)>,<,> } ]* (s80)

i80
[ 56: nonEmptyArgDefList -> nonEmptyArgDefList <,> . argDef, { <)>,<,> } ]* (s81)
[ 58: argDef -> . <id>, { <)>,<,> } ] (s83)

i81
[ 56: nonEmptyArgDefList -> nonEmptyArgDefList <,> argDef ., { <)>,<,> } ]* (r)

i82
[ 57: nonEmptyArgDefList -> argDef ., { <)>,<,> } ]* (r)

i83
[ 58: argDef -> <id> ., { <)>,<,> } ]* (r)

i84
[ 62: funcName -> <id> ., { <(> } ]* (r)

i85
[ 45: lambda -> lambdaHead . <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (s86)

i86
[ 45: lambda -> lambdaHead <arrow> . lambdaBody, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (s87)
[ 49: lambdaBody -> . <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s88)
[ 48: lambdaBody -> . assignExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s91)
[ 20: assignExpr -> . conditionalExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s94)
[ 19: assignExpr -> . assignExpr assignOptr conditionalExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s91)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s95)
[ 26: conditionalExpr -> . binaryExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s95)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s108)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s95)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s95)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s109)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s108)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s108)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s110)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s111)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s61)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s62)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s63)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s69)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s70)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s71)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s85)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow> } ] (s63)
[ 46: lambdaHead -> . <id>, { <arrow> } ] (s70)

i87
[ 45: lambda -> lambdaHead <arrow> lambdaBody ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (r)

i88
[ 49: lambdaBody -> <{> . statementList <}>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (s89)
[ 3: statementList -> ., { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function> } ] (r)
[ 2: statementList -> . statementList statement, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function> } ] (s89)

i89
[ 49: lambdaBody -> <{> statementList . <}>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (s90)
[ 2: statementList -> statementList . statement, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function> } ]* (s8)
[ 9: statement -> . <;>, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function> } ] (s34)
[ 8: statement -> . exprList <;>, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function> } ] (s35)
[ 7: statement -> . <{> statementList <}>, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function> } ] (s37)
[ 6: statement -> . whileStatement <;>, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function> } ] (s40)
[ 5: statement -> . forStatement <;>, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function> } ] (s42)
[ 4: statement -> . ifStatement <;>, { <(>,<id>,<num>,<;>,<{>,<}>,<if>,<while>,<for>,<function> } ] (s44)
[ 18: exprList -> . assignExpr, { <,>,<;> } ] (s53)
[ 17: exprList -> . exprList <,> assignExpr, { <,>,<;> } ] (s35)
[ 14: whileStatement -> . <while> <(> exprList <)> statement, { <;> } ] (s9)
[ 15: forStatement -> . <for> <(> forExpr <;> exprList <;> exprList <;> <)> statement, { <;> } ] (s14)
[ 11: ifStatement -> . <if> @1 <(> exprList <)> statement elseStatement, { <;> } ] (s25)
[ 20: assignExpr -> . conditionalExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s94)
[ 19: assignExpr -> . assignExpr assignOptr conditionalExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s53)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 26: conditionalExpr -> . binaryExpr, { <,>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s109)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s110)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=> } ] (s111)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s61)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s62)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s63)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s69)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s70)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s71)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<,>,<?>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s85)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow> } ] (s63)
[ 46: lambdaHead -> . <id>, { <arrow> } ] (s70)

i90
[ 49: lambdaBody -> <{> statementList <}> ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (r)

i91
[ 48: lambdaBody -> assignExpr ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (r)
[ 19: assignExpr -> assignExpr . assignOptr conditionalExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (s92)
[ 25: assignOptr -> . </=>, { <(>,<id>,<num>,<function> } ] (s3)
[ 24: assignOptr -> . <*=>, { <(>,<id>,<num>,<function> } ] (s4)
[ 23: assignOptr -> . <-=>, { <(>,<id>,<num>,<function> } ] (s5)
[ 22: assignOptr -> . <+=>, { <(>,<id>,<num>,<function> } ] (s6)
[ 21: assignOptr -> . <=>, { <(>,<id>,<num>,<function> } ] (s7)

i92
[ 19: assignExpr -> assignExpr assignOptr . conditionalExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (s93)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s95)
[ 26: conditionalExpr -> . binaryExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s95)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s108)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s95)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s95)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s109)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s108)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s108)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s110)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s111)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s61)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s62)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s63)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s69)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s70)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s71)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s85)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow> } ] (s63)
[ 46: lambdaHead -> . <id>, { <arrow> } ] (s70)

i93
[ 19: assignExpr -> assignExpr assignOptr conditionalExpr ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (r)

i94
[ 20: assignExpr -> conditionalExpr ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (r)

i95
[ 27: conditionalExpr -> binaryExpr . <?> assignExpr <:> assignExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (s96)
[ 26: conditionalExpr -> binaryExpr ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (r)
[ 29: binaryExpr -> binaryExpr . <-> multiplyExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (s100)
[ 28: binaryExpr -> binaryExpr . <+> multiplyExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (s106)

i96
[ 27: conditionalExpr -> binaryExpr <?> . assignExpr <:> assignExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (s97)
[ 20: assignExpr -> . conditionalExpr, { <:>,<=>,<+=>,<-=>,<*=>,</=> } ] (s94)
[ 19: assignExpr -> . assignExpr assignOptr conditionalExpr, { <:>,<=>,<+=>,<-=>,<*=>,</=> } ] (s97)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <:>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 26: conditionalExpr -> . binaryExpr, { <:>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,<?>,<:>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,<?>,<:>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,<?>,<:>,<=>,<+=>,<-=>,<*=>,</=> } ] (s95)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<?>,<:>,<=>,<+=>,<-=>,<*=>,</=> } ] (s109)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<?>,<:>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<?>,<:>,<=>,<+=>,<-=>,<*=>,</=> } ] (s108)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<?>,<:>,<=>,<+=>,<-=>,<*=>,</=> } ] (s110)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<?>,<:>,<=>,<+=>,<-=>,<*=>,</=> } ] (s111)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<?>,<:>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s61)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<?>,<:>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s62)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<?>,<:>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s63)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<?>,<:>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s69)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<?>,<:>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s70)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<?>,<:>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s71)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<?>,<:>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<member> } ] (s85)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow> } ] (s63)
[ 46: lambdaHead -> . <id>, { <arrow> } ] (s70)

i97
[ 27: conditionalExpr -> binaryExpr <?> assignExpr . <:> assignExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (s98)
[ 19: assignExpr -> assignExpr . assignOptr conditionalExpr, { <:>,<=>,<+=>,<-=>,<*=>,</=> } ]* (s92)
[ 25: assignOptr -> . </=>, { <(>,<id>,<num>,<function> } ] (s3)
[ 24: assignOptr -> . <*=>, { <(>,<id>,<num>,<function> } ] (s4)
[ 23: assignOptr -> . <-=>, { <(>,<id>,<num>,<function> } ] (s5)
[ 22: assignOptr -> . <+=>, { <(>,<id>,<num>,<function> } ] (s6)
[ 21: assignOptr -> . <=>, { <(>,<id>,<num>,<function> } ] (s7)

i98
[ 27: conditionalExpr -> binaryExpr <?> assignExpr <:> . assignExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (s99)
[ 20: assignExpr -> . conditionalExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s94)
[ 19: assignExpr -> . assignExpr assignOptr conditionalExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s99)
[ 27: conditionalExpr -> . binaryExpr <?> assignExpr <:> assignExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s95)
[ 26: conditionalExpr -> . binaryExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s95)
[ 30: binaryExpr -> . multiplyExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s108)
[ 29: binaryExpr -> . binaryExpr <-> multiplyExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s95)
[ 28: binaryExpr -> . binaryExpr <+> multiplyExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s95)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s109)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s108)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s108)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s110)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s111)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s61)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s62)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s63)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s69)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s70)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s71)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s85)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow> } ] (s63)
[ 46: lambdaHead -> . <id>, { <arrow> } ] (s70)

i99
[ 27: conditionalExpr -> binaryExpr <?> assignExpr <:> assignExpr ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (r)
[ 19: assignExpr -> assignExpr . assignOptr conditionalExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (s92)
[ 25: assignOptr -> . </=>, { <(>,<id>,<num>,<function> } ] (s3)
[ 24: assignOptr -> . <*=>, { <(>,<id>,<num>,<function> } ] (s4)
[ 23: assignOptr -> . <-=>, { <(>,<id>,<num>,<function> } ] (s5)
[ 22: assignOptr -> . <+=>, { <(>,<id>,<num>,<function> } ] (s6)
[ 21: assignOptr -> . <=>, { <(>,<id>,<num>,<function> } ] (s7)

i100
[ 29: binaryExpr -> binaryExpr <-> . multiplyExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (s101)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s109)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s101)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s101)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s110)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s111)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s61)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s62)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s63)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s69)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s70)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s71)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s85)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow> } ] (s63)
[ 46: lambdaHead -> . <id>, { <arrow> } ] (s70)

i101
[ 29: binaryExpr -> binaryExpr <-> multiplyExpr ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (r)
[ 32: multiplyExpr -> multiplyExpr . </> unaryExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (s102)
[ 31: multiplyExpr -> multiplyExpr . <*> unaryExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (s104)

i102
[ 32: multiplyExpr -> multiplyExpr </> . unaryExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (s103)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s110)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s111)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s61)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s62)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s63)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s69)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s70)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s71)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s85)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow> } ] (s63)
[ 46: lambdaHead -> . <id>, { <arrow> } ] (s70)

i103
[ 32: multiplyExpr -> multiplyExpr </> unaryExpr ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (r)

i104
[ 31: multiplyExpr -> multiplyExpr <*> . unaryExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (s105)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s110)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s111)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s61)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s62)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s63)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s69)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s70)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s71)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s85)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow> } ] (s63)
[ 46: lambdaHead -> . <id>, { <arrow> } ] (s70)

i105
[ 31: multiplyExpr -> multiplyExpr <*> unaryExpr ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (r)

i106
[ 28: binaryExpr -> binaryExpr <+> . multiplyExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (s107)
[ 33: multiplyExpr -> . unaryExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s109)
[ 32: multiplyExpr -> . multiplyExpr </> unaryExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s107)
[ 31: multiplyExpr -> . multiplyExpr <*> unaryExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s107)
[ 34: unaryExpr -> . atomicExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s110)
[ 35: atomicExpr -> . atom trailer, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s111)
[ 44: atom -> . aFunction, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s61)
[ 43: atom -> . lambda, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s62)
[ 42: atom -> . <(> exprList <)>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s63)
[ 41: atom -> . <num>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s69)
[ 40: atom -> . <id>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s70)
[ 61: aFunction -> . <function> funcName <(> argDefList <)> <{> statementList <}>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s71)
[ 45: lambda -> . lambdaHead <arrow> lambdaBody, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s85)
[ 47: lambdaHead -> . <(> argList <)>, { <arrow> } ] (s63)
[ 46: lambdaHead -> . <id>, { <arrow> } ] (s70)

i107
[ 28: binaryExpr -> binaryExpr <+> multiplyExpr ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (r)
[ 32: multiplyExpr -> multiplyExpr . </> unaryExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (s102)
[ 31: multiplyExpr -> multiplyExpr . <*> unaryExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (s104)

i108
[ 30: binaryExpr -> multiplyExpr ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (r)
[ 32: multiplyExpr -> multiplyExpr . </> unaryExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (s102)
[ 31: multiplyExpr -> multiplyExpr . <*> unaryExpr, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (s104)

i109
[ 33: multiplyExpr -> unaryExpr ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (r)

i110
[ 34: unaryExpr -> atomicExpr ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (r)

i111
[ 35: atomicExpr -> atom . trailer, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (s112)
[ 39: trailer -> ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (r)
[ 38: trailer -> . trailer <member>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s112)
[ 37: trailer -> . trailer <(> argList <)>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s112)
[ 36: trailer -> . trailer <[> subscript <]>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ] (s112)

i112
[ 35: atomicExpr -> atom trailer ., { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (r)
[ 38: trailer -> trailer . <member>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (s54)
[ 37: trailer -> trailer . <(> argList <)>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (s55)
[ 36: trailer -> trailer . <[> subscript <]>, { <+>,<->,</>,<*>,<(>,<)>,<,>,<?>,<:>,<;>,<=>,<+=>,<-=>,<*=>,</=>,<[>,<]>,<member> } ]* (s58)

